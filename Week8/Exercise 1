#!/usr/bin/env python
# coding: utf-8

# In[1]:


from __future__ import annotations

import hashlib
import hmac
import logging
import os
import re
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any


# ---------- Logging setup ----------
def setup_audit_logger(log_file: str = "auth_audit.log") -> logging.Logger:
    logger = logging.getLogger("auth")
    logger.setLevel(logging.INFO)
    logger.handlers.clear()

    fmt = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s")

    file_handler = logging.FileHandler(log_file, mode="w", encoding="utf-8")
    file_handler.setFormatter(fmt)
    logger.addHandler(file_handler)

    # Optional: show warnings+ in console (keeps console readable)
    console = logging.StreamHandler()
    console.setLevel(logging.WARNING)
    console.setFormatter(fmt)
    logger.addHandler(console)

    return logger


AUDIT = setup_audit_logger()


# ---------- Helpers ----------
USERNAME_RE = re.compile(r"^[A-Za-z0-9_.-]{3,32}$")
VALID_PRIVILEGES = {"admin", "standard", "guest"}


def _now_iso() -> str:
    return datetime.utcnow().replace(microsecond=0).isoformat() + "Z"


def _validate_username(username: str) -> str:
    if not isinstance(username, str):
        raise TypeError("username must be a string")
    username = username.strip()
    if not USERNAME_RE.match(username):
        raise ValueError("username must be 3–32 chars and use letters/numbers/._- only")
    return username


def _validate_privilege(priv: str) -> str:
    if not isinstance(priv, str):
        raise TypeError("privilege must be a string")
    priv = priv.strip().lower()
    if priv not in VALID_PRIVILEGES:
        raise ValueError(f"privilege must be one of {sorted(VALID_PRIVILEGES)}")
    return priv


def _validate_password_policy(password: str) -> None:
    # You can tighten/relax these rules. This is a "secure default".
    if not isinstance(password, str):
        raise TypeError("password must be a string")
    if len(password) < 10:
        raise ValueError("password too short (min 10)")
    if not any("A" <= c <= "Z" for c in password):
        raise ValueError("password must contain an uppercase letter")
    if not any("a" <= c <= "z" for c in password):
        raise ValueError("password must contain a lowercase letter")
    if not any("0" <= c <= "9" for c in password):
        raise ValueError("password must contain a digit")


def _hash_password(password: str, salt: bytes, rounds: int = 200_000) -> bytes:
    # PBKDF2-HMAC-SHA256 is standard-library and strong enough for labs.
    return hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, rounds)


@dataclass(frozen=True)
class ActivityEvent:
    ts: str
    event: str
    details: Dict[str, Any]


class User:
    """
    Secure user model:
      - Sensitive fields are private
      - All important actions go through methods (encapsulation)
      - Every auth attempt is logged
    """

    def __init__(self, username: str, password: str, privilege: str = "standard"):
        self.__username = _validate_username(username)
        self.__privilege = _validate_privilege(privilege)

        _validate_password_policy(password)
        self.__salt = os.urandom(16)
        self.__password_hash = _hash_password(password, self.__salt)

        self.__login_attempts = 0
        self.__status = "active"  # active/locked
        self.__activity: list[ActivityEvent] = []

        self.log_activity("USER_CREATED", {"privilege": self.__privilege})

    # ---- Safe getters (no direct sensitive access) ----
    @property
    def username(self) -> str:
        return self.__username

    @property
    def privilege(self) -> str:
        return self.__privilege

    @property
    def status(self) -> str:
        return self.__status

    @property
    def login_attempts(self) -> int:
        return self.__login_attempts

    # ---- Safe “display” ----
    def safe_info(self) -> Dict[str, Any]:
        """Required: safely display info without exposing sensitive data."""
        return {
            "username": self.__username,
            "privilege": self.__privilege,
            "status": self.__status,
            "login_attempts": self.__login_attempts,
        }

    def __repr__(self) -> str:
        # Prevent leaking hashes/salt in string representations
        info = self.safe_info()
        return f"User(username={info['username']!r}, privilege={info['privilege']!r}, status={info['status']!r})"

    # ---- Logging ----
    def log_activity(self, event: str, details: Optional[Dict[str, Any]] = None) -> None:
        details = details or {}
        ev = ActivityEvent(ts=_now_iso(), event=event, details=details)
        self.__activity.append(ev)
        AUDIT.info("user=%s event=%s details=%s", self.__username, event, details)

    def activity_trail(self, limit: int = 20) -> list[ActivityEvent]:
        return self.__activity[-limit:]

    # ---- Core security methods ----
    def authenticate(self, password: str, source: str = "local") -> bool:
        """
        authenticate():
          - Deny if locked
          - Check hash using timing-safe compare
          - Increment attempts on failure; lock after 3 failures
          - Reset attempts on success
          - Log every attempt
        """
        if self.__status == "locked":
            self.log_activity("AUTH_DENIED_LOCKED", {"source": source})
            return False

        try:
            if not isinstance(password, str):
                raise TypeError("password must be string")
            candidate_hash = _hash_password(password, self.__salt)
            ok = hmac.compare_digest(candidate_hash, self.__password_hash)
        except Exception as e:
            self.log_activity("AUTH_ERROR", {"source": source, "error": str(e)})
            return False

        if ok:
            self.__login_attempts = 0
            self.log_activity("AUTH_SUCCESS", {"source": source})
            return True

        # failed
        self.__login_attempts += 1
        self.log_activity("AUTH_FAIL", {"source": source, "attempts": self.__login_attempts})

        if self.__login_attempts >= 3:
            self.lock_account(reason="3 failed login attempts")
        return False

    def lock_account(self, reason: str = "policy") -> None:
        """lock_account(): lock the user account."""
        self.__status = "locked"
        self.log_activity("ACCOUNT_LOCKED", {"reason": reason})

    def reset_login_attempts(self, actor: "User") -> None:
        """
        reset_login_attempts():
          - Only admin can reset someone else's attempts
          - Users can reset their own attempts only if they are active (optional policy)
        """
        if not isinstance(actor, User):
            raise TypeError("actor must be a User")

        if actor.username != self.__username and actor.privilege != "admin":
            self.log_activity("RESET_DENIED", {"by": actor.username})
            raise PermissionError("only admin can reset other users' attempts")

        self.__login_attempts = 0
        self.log_activity("RESET_ATTEMPTS", {"by": actor.username})

    def unlock_account(self, actor: "User") -> None:
        """Unlocking is privileged: admin only."""
        if actor.privilege != "admin":
            self.log_activity("UNLOCK_DENIED", {"by": actor.username})
            raise PermissionError("only admin can unlock accounts")
        self.__status = "active"
        self.__login_attempts = 0
        self.log_activity("ACCOUNT_UNLOCKED", {"by": actor.username})

    def check_privileges(self, required: str) -> bool:
        """
        check_privileges(): returns True if user has required privilege.
        Hierarchy: admin > standard > guest
        """
        required = _validate_privilege(required)
        rank = {"guest": 0, "standard": 1, "admin": 2}
        return rank[self.__privilege] >= rank[required]

    def set_password(self, actor: "User", new_password: str) -> None:
        """
        Password change is controlled and validated.
        Policy: user can change own password, admin can force-change anyone.
        """
        if not isinstance(actor, User):
            raise TypeError("actor must be a User")

        if actor.username != self.__username and actor.privilege != "admin":
            self.log_activity("PW_CHANGE_DENIED", {"by": actor.username})
            raise PermissionError("only admin can change other users' passwords")

        _validate_password_policy(new_password)
        self.__salt = os.urandom(16)
        self.__password_hash = _hash_password(new_password, self.__salt)
        self.__login_attempts = 0
        self.log_activity("PW_CHANGED", {"by": actor.username})

    def set_privilege(self, actor: "User", new_privilege: str) -> None:
        """
        Privilege escalation only through authorised method:
          - Only admin can change privileges
          - Prevents self-escalation by standard/guest
        """
        if actor.privilege != "admin":
            self.log_activity("PRIV_ESC_DENIED", {"by": actor.username, "to": new_privilege})
            raise PermissionError("only admin can change privileges")

        new_privilege = _validate_privilege(new_privilege)
        old = self.__privilege
        self.__privilege = new_privilege
        self.log_activity("PRIV_CHANGED", {"by": actor.username, "from": old, "to": new_privilege})


class AuthSystem:
    """Small manager to safely create and manage users (prevents duplicates)."""

    def __init__(self):
        self.__users: Dict[str, User] = {}

    def create_user(self, username: str, password: str, privilege: str = "standard") -> User:
        username = _validate_username(username)
        if username in self.__users:
            raise ValueError("username already exists")
        user = User(username=username, password=password, privilege=privilege)
        self.__users[username] = user
        return user

    def get_user(self, username: str) -> User:
        username = _validate_username(username)
        if username not in self.__users:
            raise KeyError("user not found")
        return self.__users[username]

    def authenticate(self, username: str, password: str, source: str = "local") -> bool:
        user = self.get_user(username)
        return user.authenticate(password, source=source)


def demo_exercise_1():
    print("=== DEMO: Exercise 1 (Secure Auth) ===")
    auth = AuthSystem()

    admin = auth.create_user("admin_user", "AdminStrongPass123", "admin")
    alice = auth.create_user("alice", "AliceStrongPass123", "standard")
    guest = auth.create_user("guest1", "GuestStrongPass123", "guest")

    # Wrong attempts -> lock
    for _ in range(3):
        ok = auth.authenticate("alice", "wrong-pass", source="demo")
        print("alice login ok?", ok, "status=", alice.status, "attempts=", alice.login_attempts)

    # Locked: even correct password denied
    ok = auth.authenticate("alice", "AliceStrongPass123", source="demo")
    print("alice correct after lock ok?", ok, "status=", alice.status)

    # Admin unlocks and resets
    alice.unlock_account(admin)
    print("alice after unlock:", alice.safe_info())

    # Privilege escalation only by admin
    try:
        guest.set_privilege(guest, "admin")
    except Exception as e:
        print("guest self-escalation blocked:", e)

    guest.set_privilege(admin, "standard")
    print("guest after admin change:", guest.safe_info())


if __name__ == "__main__":
    demo_exercise_1()


# In[ ]:




